<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraSpeak AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Plus Jakarta Sans', 'Inter', sans-serif;
            background-color: #FFFFFF; /* White Background */
        }
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #e5e7eb;
            border-bottom-color: #1B1B1D; /* Dark Gray/Black */
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Clickable word highlight style */
        .clickable-word {
            position: relative;
            cursor: pointer;
            border-radius: 3px;
            padding: 1px 2px;
            margin: 0 -2px;
            transition: background-color 0.2s;
        }
        
        .clickable-word:hover {
            background-color: rgba(255, 255, 255, 0.3);
            text-decoration: underline;
        }
        
        .saved-word {
            background-color: rgba(255, 255, 100, 0.3);
        }

        /* Word modal style */
        .word-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            width: 400px;
            z-index: 50;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 40;
        }
        
        /* Vocabulary drawer */
        .vocabulary-drawer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            max-height: 70vh;
            z-index: 30;
            transition: transform 0.3s ease-in-out;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            overflow-y: auto;
        }
        
        .vocabulary-drawer.hidden {
            transform: translateY(100%);
        }
        
        .vocabulary-drawer.visible {
            transform: translateY(0);
        }
        
        /* Voice input button animation */
        .recording {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Bottom navigation styles */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            border-top: 1px solid #e5e7eb;
            z-index: 20;
            padding: 12px 16px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .bottom-nav-container {
            max-width: 400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-around;
        }
        
        .nav-tab {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
            min-width: 80px;
        }
        
        .nav-tab.active {
            background-color: #1B1B1D;
            color: white;
        }
        
        .nav-tab:not(.active) {
            color: #6b7280;
        }
        
        .nav-tab:not(.active):hover {
            background-color: #f3f4f6;
        }
        
        .nav-icon {
            width: 24px;
            height: 24px;
        }
        
        .nav-text {
            font-size: 12px;
            font-weight: 600;
        }
        
        /* Add bottom padding to body to account for fixed nav */
        body {
            padding-bottom: 80px;
        }
        
        /* Update vocabulary drawer to account for bottom nav */
        .vocabulary-drawer {
            bottom: 80px;
            max-height: calc(70vh - 80px);
        }
        
        /* Learning mode styles */
        .learning-mode {
            display: none;
        }
        
        .learning-mode.active {
            display: block;
        }
        
        .translation-mode.active {
            display: block;
        }
        
        .translation-mode:not(.active) {
            display: none;
        }
    </style>
</head>
<body class="bg-white text-[#1B1B1D] flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-2xl mx-auto relative">
        <!-- Translation Mode Content -->
        <div id="translation-mode" class="translation-mode active">
            <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 border border-gray-200 relative z-10">
                <!-- Header -->
                <div class="text-center mb-8 relative">
                    <h1 class="text-4xl sm:text-5xl font-extrabold text-[#1B1B1D] tracking-tighter">NeuraSpeak</h1>
                    <p class="text-gray-500 mt-2 font-semibold">Instant. Nuanced. Truly You.</p>
                </div>

                <!-- Language Selection & Input -->
                <div class="space-y-4">
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <select id="source-lang" class="w-full p-3 bg-gray-100 border-2 border-gray-200 rounded-lg font-bold text-[#1B1B1D] focus:ring-4 focus:ring-blue-800/50 focus:border-blue-800 outline-none">
                            <option value="auto" selected>自動認識 (Auto Detect)</option>
                            <option value="English">English</option>
                            <option value="Japanese">Japanese</option>
                            <option value="Spanish">Spanish</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Korean">Korean</option>
                        </select>
                        <select id="target-lang" class="w-full p-3 bg-gray-100 border-2 border-gray-200 rounded-lg font-bold text-[#1B1B1D] focus:ring-4 focus:ring-blue-800/50 focus:border-blue-800 outline-none">
                            <option value="English" selected>English</option>
                            <option value="Japanese">Japanese</option>
                            <option value="Spanish">Spanish</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Korean">Korean</option>
                        </select>
                    </div>
                    
                    <div class="relative">
                        <textarea id="text-input" rows="4" class="w-full p-3 pr-12 bg-gray-100 border-2 border-gray-200 rounded-lg font-bold text-[#1B1B1D] focus:ring-4 focus:ring-[#1B1B1D]/50 focus:border-[#1B1B1D] outline-none" placeholder="翻訳したいテキストを入力してください..."></textarea>
                        <button id="mic-btn" class="absolute top-1/2 right-3 -translate-y-1/2 text-gray-400 hover:text-gray-600 p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[#1B1B1D]">
                            <svg id="mic-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                <line x1="12" y1="19" x2="12" y2="23"></line>
                            </svg>
                        </button>
                    </div>

                    <button id="translate-btn" class="w-full bg-[#1B1B1D] text-white font-extrabold text-lg py-3 px-4 rounded-lg hover:bg-opacity-90 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-[#1B1B1D]">
                        Translate
                    </button>
                </div>

                <!-- Results Section -->
                <div id="results-container" class="mt-8 space-y-6 hidden">
                    <!-- Loading Spinner -->
                    <div id="loader-container" class="text-center hidden py-8">
                        <div class="loader"></div>
                        <p class="text-gray-500 font-bold mt-4">AI is on it...</p>
                    </div>
                    
                    <!-- Error Message -->
                    <div id="error-message" class="text-center text-red-500 font-bold hidden"></div>

                    <!-- Translation Cards -->
                    <div id="translation-cards" class="space-y-4"></div>
                    
                    <!-- Vocabulary Button -->
                    <div class="flex justify-center mt-6">
                        <button id="vocabulary-btn" class="bg-gray-100 hover:bg-gray-200 text-[#1B1B1D] font-bold py-2 px-6 rounded-lg flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"></path>
                            </svg>
                            My Vocabulary List
                            <span id="vocabulary-count" class="ml-1 bg-[#1B1B1D] text-white rounded-full w-5 h-5 inline-flex items-center justify-center text-xs">0</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Signature Footer -->
            <footer class="text-center py-4">
                <p class="text-sm text-gray-500">Built by Amane Takezawa</p>
            </footer>
        </div>
        
        <!-- Learning Mode Content -->
        <div id="learning-mode" class="learning-mode">
            <div class="bg-white rounded-2xl shadow-2xl p-6 sm:p-8 border border-gray-200 relative z-10">
                <!-- Header -->
                <div class="text-center mb-8 relative">
                    <h1 class="text-4xl sm:text-5xl font-extrabold text-[#1B1B1D] tracking-tighter">NeuraSpeak</h1>
                    <p class="text-gray-500 mt-2 font-semibold">Learn with your vocabulary</p>
                </div>
                
                <!-- Learning Content Area -->
                <div id="learning-mode-content">
                    <!-- This will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- Signature Footer -->
            <footer class="text-center py-4">
                <p class="text-sm text-gray-500">Built by Amane Takezawa</p>
            </footer>
        </div>
    </div>
    
    <!-- Word Definition Modal -->
    <div id="word-modal" class="word-modal hidden">
        <div class="bg-white rounded-xl shadow-xl border border-gray-200 overflow-hidden">
            <div class="flex justify-between items-center border-b border-gray-200 p-4">
                <h3 id="modal-word" class="text-xl font-extrabold"></h3>
                <button id="close-modal" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"></path>
                        <path d="m6 6 12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="p-4 max-h-[70vh] overflow-y-auto">
                <div class="flex items-center mb-4 gap-2">
                    <div id="word-pronunciation" class="text-gray-600 flex-grow"></div>
                    <button id="play-pronunciation" class="p-1.5 rounded-md bg-gray-100 hover:bg-gray-200 transition-colors flex-shrink-0">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                        </svg>
                    </button>
                </div>
                <div id="word-definition" class="text-sm text-gray-700 space-y-2"></div>

                <!-- New Section for Contextual Meaning -->
                <div id="word-context-container" class="mt-3 hidden">
                    <h4 class="text-sm font-bold text-gray-500">この文脈での意味</h4>
                    <div id="word-context-meaning" class="mt-1 text-sm text-gray-700 space-y-2 border-l-2 pl-2"></div>
                </div>
                
                <!-- Section for Alternatives -->
                <div id="word-alternatives-container" class="mt-3 hidden">
                    <h4 class="text-sm font-bold text-gray-500">別の表現 / ニュアンス</h4>
                    <div id="word-alternatives" class="mt-1 text-sm text-gray-700 space-y-2"></div>
                </div>
                <!-- Section for Examples -->
                <div id="word-example-container" class="mt-3 hidden">
                    <h4 class="text-sm font-bold text-gray-500">例文</h4>
                    <div id="word-example" class="mt-1 text-sm text-gray-700 space-y-1"></div>
                </div>

                <div class="mt-4 pt-4 border-t border-gray-200">
                    <button id="save-word" class="w-full bg-[#1B1B1D] text-white font-bold py-2 rounded-md hover:bg-opacity-90">
                        Add to Vocabulary
                    </button>
                </div>
            </div>
        </div>
    </div>
    <div id="modal-overlay" class="modal-overlay hidden"></div>
    
    <!-- Vocabulary Drawer -->
    <div id="vocabulary-drawer" class="vocabulary-drawer hidden">
        <div class="p-4 border-b border-gray-200">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-bold">My Vocabulary List</h2>
                <button id="close-vocabulary" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"></path>
                        <path d="m6 6 12 12"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div id="vocabulary-list" class="p-4 divide-y divide-gray-200">
            <!-- Vocabulary items will be inserted here -->
        </div>
        <div class="p-4 border-t border-gray-200">
            <button id="clear-vocabulary" class="w-full bg-red-500 text-white font-bold py-2 rounded-md hover:bg-red-600">
                Clear Vocabulary
            </button>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <div class="bottom-nav-container">
            <div class="nav-tab active" data-mode="translation">
                <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M5 8l6 6"/>
                    <path d="M4 14l6-6 2-3"/>
                    <path d="M2 5h12"/>
                    <path d="M7 2h1"/>
                    <path d="M22 22l-5-10-5 10"/>
                    <path d="M14 18h6"/>
                </svg>
                <span class="nav-text">翻訳</span>
            </div>
            <div class="nav-tab" data-mode="learning">
                <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>
                </svg>
                <span class="nav-text">学ぶ</span>
            </div>
        </div>
    </nav>

    <script>
        // DOM Elements
        const translateBtn = document.getElementById('translate-btn');
        const textInput = document.getElementById('text-input');
        const sourceLangSelect = document.getElementById('source-lang');
        const targetLangSelect = document.getElementById('target-lang');
        const resultsContainer = document.getElementById('results-container');
        const loader = document.getElementById('loader-container');
        const errorMessage = document.getElementById('error-message');
        const translationCards = document.getElementById('translation-cards');
        const micBtn = document.getElementById('mic-btn');
        const micIcon = document.getElementById('mic-icon');
        
        // Vocabulary and word definition elements
        const wordModal = document.getElementById('word-modal');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalWord = document.getElementById('modal-word');
        const wordPronunciation = document.getElementById('word-pronunciation');
        const wordDefinition = document.getElementById('word-definition');
        const playPronunciation = document.getElementById('play-pronunciation');
        const saveWordBtn = document.getElementById('save-word');
        const closeModalBtn = document.getElementById('close-modal');
        const vocabularyBtn = document.getElementById('vocabulary-btn');
        const vocabularyCount = document.getElementById('vocabulary-count');
        const vocabularyDrawer = document.getElementById('vocabulary-drawer');
        const vocabularyList = document.getElementById('vocabulary-list');
        const closeVocabularyBtn = document.getElementById('close-vocabulary');
        const clearVocabularyBtn = document.getElementById('clear-vocabulary');
        
        // Learning Mode Elements
        const learningModeContent = document.getElementById('learning-mode-content');
        
        // State variables
        let vocabularyItems = JSON.parse(localStorage.getItem('vocabulary') || '[]');
        let currentWord = null;
        let quizState = {};

        // --- Speech Recognition ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = getLangCode(sourceLangSelect.value);
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                micBtn.classList.add('recording');
                micIcon.classList.add('text-red-500');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                textInput.value = transcript;
            };

            recognition.onspeechend = () => {
                recognition.stop();
            };
            
            recognition.onend = () => {
                micBtn.classList.remove('recording');
                micIcon.classList.remove('text-red-500');
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                micBtn.classList.remove('recording');
                micIcon.classList.remove('text-red-500');
            };
        } else {
            console.log("Speech Recognition not supported");
            micBtn.style.display = 'none';
        }

        // --- TTS Voice Loading ---
        let voices = [];
        function populateVoiceList() {
            if(typeof speechSynthesis === 'undefined') return;
            voices = speechSynthesis.getVoices();
        }
        populateVoiceList();
        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        // --- Event Listeners ---
        translateBtn.addEventListener('click', handleTranslation);
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleTranslation();
            }
        });

        if (micBtn) {
            micBtn.addEventListener('click', () => {
                recognition.lang = getLangCode(sourceLangSelect.value);
                recognition.start();
            });
        }
        
        closeModalBtn.addEventListener('click', closeWordModal);
        modalOverlay.addEventListener('click', closeWordModal);
        saveWordBtn.addEventListener('click', saveWordToVocabulary);
        playPronunciation.addEventListener('click', () => {
            if (currentWord) {
                speakText(currentWord.word, getLangCode(targetLangSelect.value));
            }
        });
        
        vocabularyBtn.addEventListener('click', toggleVocabularyDrawer);
        closeVocabularyBtn.addEventListener('click', closeVocabularyDrawer);
        clearVocabularyBtn.addEventListener('click', clearVocabulary);
        
        updateVocabularyCount();

        // --- Main Translation Handler ---
        async function handleTranslation() {
            const text = textInput.value.trim();
            if (!text) {
                showError("翻訳するテキストを入力してください。");
                return;
            }
            showLoader(true);
            clearResults();
            try {
                const result = await getAiTranslation(text, sourceLangSelect.value, targetLangSelect.value);
                if (result) displayResults(result);
            } catch (error) {
                console.error("Translation error:", error);
                showError("翻訳中にエラーが発生しました。もう一度お試しください。");
            } finally {
                showLoader(false);
            }
        }

        // --- AI API Calls ---
        async function getAiTranslation(text, sourceLang, targetLang) {
            let sourceLanguageInstruction = `Source Language: ${sourceLang}`;
            if (sourceLang === 'auto') {
                sourceLanguageInstruction = `Source Language: Auto-detect`;
            }
            const prompt = `
[ROLE]
You are a world-class, expert multilingual translator and linguist. Your accuracy is crucial.

[TASK]
Your primary task is to translate the user's text, provide stylistic variations, recommend the best nuance, and predict logical follow-up phrases. You must strictly follow all instructions and output format.

[INPUT]
- User Text: "${text}"
- ${sourceLanguageInstruction}
- Target Language: ${targetLang}

[INSTRUCTIONS]
1.  **Analyze and Translate**: Analyze the user's text. If the source language is "Auto-detect", first identify the language. Then, provide three variations of the translation in the target language: standard, casual, and polite.
2.  **Back-Translate for Nuance**: For each of the three translation variations, create a "source_nuance". This field MUST be a direct, literal back-translation of your translated text **and MUST be written in the source language**. 
3.  **Recommend Best Nuance**: Based on the user's text, determine the most appropriate nuance. Add a field "recommendedNuance" to the JSON root. Its value MUST be one of: "standard", "casual", or "polite".
4.  **Predict Next Actions**: Generate an array of three *different* and *logical* follow-up sentences a user might say. These must be distinct from the main translations. For each prediction, provide both the target language version and the source language version.
5.  **Format Output**: Your final output must be a single, valid JSON object and nothing else.

[EXAMPLE OF PERFECT OUTPUT]
- User Text: "メニューを見せてください。"
- Source Language: "Japanese"
- Target Language: "English"
- Expected JSON Output:
{
  "recommendedNuance": "standard",
  "standardTranslation": { "target": "Please show me the menu.", "source_nuance": "メニューを見せてください。" },
  "casualTranslation": { "target": "Can I see the menu?", "source_nuance": "メニュー見てもいい？" },
  "politeTranslation": { "target": "Could you please bring me the menu?", "source_nuance": "メニューを持ってきていただけますか？" },
  "predictedSentences": [
    { "target": "I'll have this, please.", "source": "これをお願いします。" },
    { "target": "Do you have a Japanese menu?", "source": "日本語のメニューはありますか？" },
    { "target": "The check, please.", "source": "お会計をお願いします。" }
  ]
}

[OUTPUT FORMAT]
Respond ONLY with the valid JSON object based on the schema.
`;
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            // In a real application, you should hide your API key.
            const apiKey = ""; // Your API Key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API request failed`);
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return JSON.parse(result.candidates[0].content.parts[0].text);
            } else {
                throw new Error("Invalid response from API.");
            }
        }

        // --- DOM Manipulation ---
        function displayResults(data) {
            clearResults();
            if (data.detectedSourceLanguage) {
                const option = Array.from(sourceLangSelect.options).find(opt => opt.value.toLowerCase() === data.detectedSourceLanguage.toLowerCase());
                if (option) sourceLangSelect.value = option.value;
            }

            const results = [];
            const recommendedType = data.recommendedNuance || 'standard';

            const colorMap = {
                standard: { highlightBgColor: '#1B1B1D' }, // Black
                casual:   { highlightBgColor: '#FF6F61' }, // Coral Pink
                polite:   { highlightBgColor: '#1e3a8a' }  // Navy
            };

            if (data.standardTranslation) results.push({ type: 'standard', title: 'Standard', data: data.standardTranslation, colors: colorMap.standard });
            if (data.casualTranslation) results.push({ type: 'casual', title: 'Casual', data: data.casualTranslation, colors: colorMap.casual });
            if (data.politeTranslation) results.push({ type: 'polite', title: 'Polite', data: data.politeTranslation, colors: colorMap.polite });

            results.sort((a, b) => {
                if (a.type === recommendedType) return -1;
                if (b.type === recommendedType) return 1;
                const order = { standard: 1, casual: 2, polite: 3 };
                return order[a.type] - order[b.type];
            });

            const tabContainer = document.createElement('div');
            const tabNav = document.createElement('div');
            tabNav.className = 'flex bg-gray-100 rounded-lg p-1 space-x-1';
            const tabContentContainer = document.createElement('div');
            tabContentContainer.className = 'mt-4';

            results.forEach(result => {
                const tabButton = document.createElement('button');
                tabButton.dataset.tab = result.type;
                tabButton.className = 'w-full py-2 px-4 rounded-md font-bold transition-colors text-sm flex items-center justify-center gap-2';

                tabButton.innerHTML = result.type === recommendedType ? `<svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 0L14.5 9.5L24 12L14.5 14.5L12 24L9.5 14.5L0 12L9.5 9.5L12 0Z"></path></svg> ${result.title}` : result.title;

                const contentPanel = document.createElement('div');
                contentPanel.id = `content-${result.type}`;
                contentPanel.className = 'hidden';
                createResultCardContent(contentPanel, result.data, result.colors);

                if (result.type === recommendedType) {
                    tabButton.classList.add('bg-white', 'text-gray-900', 'shadow');
                    contentPanel.classList.remove('hidden');
                } else {
                    tabButton.classList.add('text-gray-500', 'hover:bg-gray-200');
                }

                tabNav.appendChild(tabButton);
                tabContentContainer.appendChild(contentPanel);
            });

            tabNav.addEventListener('click', (e) => {
                const clickedButton = e.target.closest('button');
                if (clickedButton) {
                    const targetTab = clickedButton.dataset.tab;
                    tabNav.querySelectorAll('button').forEach(btn => {
                        btn.classList.remove('bg-white', 'text-gray-900', 'shadow');
                        btn.classList.add('text-gray-500', 'hover:bg-gray-200');
                    });
                    clickedButton.classList.add('bg-white', 'text-gray-900', 'shadow');
                    tabContentContainer.querySelectorAll('div[id^="content-"]').forEach(panel => panel.classList.add('hidden'));
                    document.getElementById(`content-${targetTab}`).classList.remove('hidden');
                }
            });

            tabContainer.appendChild(tabNav);
            tabContainer.appendChild(tabContentContainer);
            translationCards.appendChild(tabContainer);

            if(data.predictedSentences?.length > 0) createPredictedSentencesCard(data.predictedSentences);
        }

        function createResultCardContent(panel, translationData, colors) {
            const contentBox = document.createElement('div');
            contentBox.style.backgroundColor = colors.highlightBgColor;
            contentBox.className = 'p-3 rounded-lg flex justify-between items-center';
            
            const contentTextElement = document.createElement('div');
            contentTextElement.className = 'text-white text-xl font-bold flex-grow';
            
            const words = translationData.target.split(/\b/);
            words.forEach(word => {
                if (word.trim() && /^[a-zA-Z0-9'-]+$/.test(word)) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'clickable-word';
                    wordSpan.textContent = word;
                    if (isWordInVocabulary(word)) wordSpan.classList.add('saved-word');
                    wordSpan.addEventListener('click', () => showWordDefinition(word, translationData.target)); // Pass context
                    contentTextElement.appendChild(wordSpan);
                } else {
                    contentTextElement.appendChild(document.createTextNode(word));
                }
            });
            
            contentBox.appendChild(contentTextElement);

            const controlsWrapper = document.createElement('div');
            controlsWrapper.className = 'flex items-center space-x-1 flex-shrink-0';
            controlsWrapper.appendChild(createSpeakButton(translationData.target, 'text-white'));
            controlsWrapper.appendChild(createCopyButton(translationData.target, 'text-white'));
            contentBox.appendChild(controlsWrapper);
            panel.appendChild(contentBox);

            const nuanceContainer = document.createElement('div');
            nuanceContainer.className = 'mt-3 border-t border-gray-200 pt-3';
            const nuanceTextElement = document.createElement('p');
            nuanceTextElement.className = 'text-sm text-[#1B1B1D] font-bold';
            nuanceTextElement.textContent = translationData.source_nuance;
            nuanceContainer.appendChild(nuanceTextElement);
            panel.appendChild(nuanceContainer);
        }
        
        function createPredictedSentencesCard(sentences) {
            const container = document.createElement('div');
            container.className = 'bg-gray-50 p-4 rounded-lg border-2 border-gray-200';
            const title = document.createElement('h3');
            title.className = 'text-sm font-extrabold text-gray-400 mb-3 tracking-wider uppercase';
            title.textContent = 'Next Actions';
            container.appendChild(title);
            const list = document.createElement('div');
            list.className = 'space-y-2';
            sentences.forEach(sentenceObj => {
                const item = document.createElement('div');
                item.className = 'bg-white p-3 rounded-md border border-gray-200 flex justify-between items-center';
                const textWrapper = document.createElement('div');
                textWrapper.className = 'flex-grow pr-2';
                
                const targetText = document.createElement('p');
                targetText.className = 'text-[#1B1B1D] font-bold';
                
                const words = sentenceObj.target.split(/\b/);
                words.forEach(word => {
                    if (word.trim() && /^[a-zA-Z0-9'-]+$/.test(word)) {
                        const wordSpan = document.createElement('span');
                        wordSpan.className = 'clickable-word';
                        wordSpan.textContent = word;
                        if (isWordInVocabulary(word)) wordSpan.classList.add('saved-word');
                        wordSpan.addEventListener('click', () => showWordDefinition(word, sentenceObj.target)); // Pass context
                        targetText.appendChild(wordSpan);
                    } else {
                        targetText.appendChild(document.createTextNode(word));
                    }
                });
                
                textWrapper.appendChild(targetText);
                const sourceText = document.createElement('p');
                sourceText.className = 'text-sm text-gray-500';
                sourceText.textContent = sentenceObj.source;
                textWrapper.appendChild(sourceText);
                item.appendChild(textWrapper);
                const controlsWrapper = document.createElement('div');
                controlsWrapper.className = 'flex items-center space-x-1 flex-shrink-0';
                controlsWrapper.appendChild(createSpeakButton(sentenceObj.target, 'text-gray-400'));
                controlsWrapper.appendChild(createCopyButton(sentenceObj.target, 'text-gray-400'));
                item.appendChild(controlsWrapper);
                list.appendChild(item);
            });
            container.appendChild(list);
            translationCards.appendChild(container);
        }

        // --- Word Definition Functions ---
        async function showWordDefinition(word, contextSentence) {
            currentWord = null;
            modalWord.textContent = word;
            wordPronunciation.textContent = "検索中...";
            wordDefinition.innerHTML = '<div class="animate-pulse">意味を調べています...</div>';
            document.getElementById('word-context-container').classList.add('hidden');
            document.getElementById('word-alternatives-container').classList.add('hidden');
            document.getElementById('word-example-container').classList.add('hidden');
            
            openWordModal();
            
            try {
                const wordLanguage = targetLangSelect.value;
                const definitionLanguage = sourceLangSelect.value === 'auto' ? 'Japanese' : sourceLangSelect.value;
                
                const definition = await getComprehensiveDefinition(word, wordLanguage, definitionLanguage, contextSentence);
                currentWord = {
                    word: word,
                    definition: definition
                };
                
                if (isWordInVocabulary(word)) {
                    saveWordBtn.textContent = "単語帳から削除";
                    saveWordBtn.classList.replace("bg-[#1B1B1D]", "bg-red-500");
                } else {
                    saveWordBtn.textContent = "単語帳に追加";
                    saveWordBtn.classList.replace("bg-red-500", "bg-[#1B1B1D]");
                }
                
                updateWordModal(definition);
            } catch (error) {
                console.error("Failed to fetch word definition:", error);
                wordPronunciation.textContent = "";
                wordDefinition.innerHTML = `<p class="text-red-500">意味の読み込みに失敗しました。「${word}」は辞書にないか、スラングの可能性があります。</p>`;
            }
        }
        
        async function getComprehensiveDefinition(word, wordLanguage, definitionLanguage, contextSentence) {
            // If the desired definition is not in English, use AI directly.
            if (definitionLanguage !== 'English') {
                return getAiDefinition(word, wordLanguage, definitionLanguage, contextSentence);
            }

            // Fallback Chain for English -> English definitions
            try {
                // 1. Try standard dictionary
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word.toLowerCase())}`);
                if (!response.ok) throw new Error("Not in standard dictionary.");
                const data = await response.json();
                const aiData = await getAiDefinition(word, wordLanguage, definitionLanguage, contextSentence);
                return transformDictionaryApiData(data[0], aiData);
            } catch (error1) {
                try {
                    // 2. Try slang dictionary
                    const response = await fetch(`https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(word.toLowerCase())}`);
                    if (!response.ok) throw new Error("Urban Dictionary API failed.");
                    const data = await response.json();
                    if (!data.list || data.list.length === 0) throw new Error("Not in Urban Dictionary.");
                    const aiData = await getAiDefinition(word, wordLanguage, definitionLanguage, contextSentence);
                    return transformUrbanDictData(data.list[0], aiData);
                } catch (error2) {
                    // 3. Final fallback to AI
                    return getAiDefinition(word, wordLanguage, definitionLanguage, contextSentence);
                }
            }
        }

        function transformDictionaryApiData(apiData, aiData) {
            return {
                pronunciation: apiData.phonetic || (apiData.phonetics.length > 0 ? apiData.phonetics.find(p => p.text)?.text : "N/A"),
                partOfSpeech: apiData.meanings[0]?.partOfSpeech || "N/A",
                definition: apiData.meanings[0]?.definitions[0]?.definition || "No definition found.",
                contextualMeaning: aiData.contextualMeaning || null,
                alternatives: aiData.alternatives || [],
                example: aiData.example || null
            };
        }

        function transformUrbanDictData(apiData, aiData) {
            return {
                pronunciation: aiData.pronunciation || "N/A",
                partOfSpeech: "slang",
                definition: apiData.definition.replace(/[\[\]]/g, ''),
                contextualMeaning: aiData.contextualMeaning || null,
                alternatives: aiData.alternatives || [],
                example: {
                    source: apiData.example.replace(/[\[\]]/g, ''),
                    target: aiData.example?.target || "(Example translation by AI)"
                }
            };
        }

        async function getAiDefinition(word, wordLanguage, definitionLanguage, contextSentence) {
            const prompt = `
[ROLE]
You are a helpful multilingual dictionary assistant. Your task is to provide a detailed, structured definition for a given word, paying special attention to its context.

[TASK]
Analyze the user's word within the provided sentence context and provide a comprehensive definition in the specified definition language.

[INPUT]
- Word to Define: "${word}"
- Context Sentence: "${contextSentence}"
- Language of the Word: "${wordLanguage}"
- Language for the Definition: "${definitionLanguage}"

[INSTRUCTIONS]
1.  **Contextual Meaning**: CRITICAL - Based on the [Context Sentence], provide a specific definition of how the word is used in that sentence. This MUST be written in the "${definitionLanguage}".
2.  **General Definition**: Provide a clear and concise general definition of the word. This definition MUST be written in the "${definitionLanguage}".
3.  **Pronunciation**: Provide the phonetic transcription for the word.
4.  **Part of Speech**: Identify the part of speech (e.g., noun, verb, adjective). This MUST be written in the "${definitionLanguage}".
5.  **Alternatives**: List up to two common alternative or slang expressions related to the word. For each alternative, provide the expression itself and a brief explanation of its nuance. The explanation MUST be in the "${definitionLanguage}". If no alternatives are common, return an empty array. For "want to", you must include "wanna".
6.  **Example**: Provide one clear example sentence using the word. The sentence should be in the "${wordLanguage}", and you MUST also provide its translation in the "${definitionLanguage}".
7.  **Format**: Your final output must be a single, valid JSON object and nothing else. Do not include any text before or after the JSON object.

[EXAMPLE OF PERFECT JSON OUTPUT]
- Word to Define: "happy"
- Context Sentence: "She looks very happy with her new puppy."
- Language of the Word: "English"
- Language for the Definition: "Japanese"
- Expected JSON Output:
{
  "contextualMeaning": "この文脈では、新しい子犬を手に入れたことによる喜びや満足感を表しています。",
  "pronunciation": "/ˈhæpi/",
  "partOfSpeech": "形容詞",
  "definition": "幸福や喜びを感じている、または示している状態。",
  "alternatives": [
    { "expression": "glad", "nuance": "特定の出来事に対する喜びを表す、より一時的な感情。" },
    { "expression": "pleased", "nuance": "満足感や喜びを表す、よりフォーマルな表現。" }
  ],
  "example": {
    "source": "She looks very happy.",
    "target": "彼女はとても幸せそうです。"
  }
}

[OUTPUT FORMAT]
Respond ONLY with the valid JSON object based on the schema.
`;
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            // In a real application, you should hide your API key.
            const apiKey = ""; // Your API Key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`AI definition API request failed`);
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                let jsonString = result.candidates[0].content.parts[0].text;
                jsonString = jsonString.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                return JSON.parse(jsonString);
            } else {
                throw new Error("Invalid response from AI definition API.");
            }
        }
        
        function updateWordModal(data) {
            wordPronunciation.textContent = data.pronunciation || "発音情報なし";
            
            // General Definition
            wordDefinition.innerHTML = "";
            const partOfSpeech = document.createElement('p');
            partOfSpeech.className = "text-sm font-bold text-gray-500";
            partOfSpeech.textContent = data.partOfSpeech || "品詞不明";
            wordDefinition.appendChild(partOfSpeech);

            const definitionText = document.createElement('p');
            definitionText.textContent = data.definition || "定義が見つかりませんでした。";
            wordDefinition.appendChild(definitionText);

            // Contextual Meaning
            const contextContainer = document.getElementById('word-context-container');
            const contextMeaning = document.getElementById('word-context-meaning');
            contextMeaning.innerHTML = "";
            if (data.contextualMeaning) {
                contextMeaning.textContent = data.contextualMeaning;
                contextContainer.classList.remove('hidden');
            } else {
                contextContainer.classList.add('hidden');
            }

            // Alternatives
            const alternativesContainer = document.getElementById('word-alternatives-container');
            const alternativesList = document.getElementById('word-alternatives');
            alternativesList.innerHTML = "";
            if (data.alternatives && data.alternatives.length > 0) {
                data.alternatives.forEach(alt => {
                    const item = document.createElement('div');
                    item.className = "border-l-2 pl-2";
                    item.innerHTML = `<p class="font-bold">${alt.expression}</p><p class="text-xs text-gray-600">${alt.nuance}</p>`;
                    alternativesList.appendChild(item);
                });
                alternativesContainer.classList.remove('hidden');
            } else {
                alternativesContainer.classList.add('hidden');
            }

            // Example Sentence
            const exampleContainer = document.getElementById('word-example-container');
            const exampleContent = document.getElementById('word-example');
            exampleContent.innerHTML = "";
            if (data.example && data.example.source) {
                exampleContent.innerHTML = `<p class="italic">"${data.example.source}"</p><p class="text-gray-600">${data.example.target}</p>`;
                exampleContainer.classList.remove('hidden');
            } else {
                exampleContainer.classList.add('hidden');
            }
        }
        
        function openWordModal() {
            wordModal.classList.remove('hidden');
            modalOverlay.classList.remove('hidden');
        }
        
        function closeWordModal() {
            wordModal.classList.add('hidden');
            modalOverlay.classList.add('hidden');
            currentWord = null;
        }
        
        // --- Vocabulary Functions ---
        function saveWordToVocabulary() {
            if (!currentWord) return;
            
            const wordIndex = vocabularyItems.findIndex(item => item.word.toLowerCase() === currentWord.word.toLowerCase());
            
            if (wordIndex === -1) {
                vocabularyItems.push({ word: currentWord.word, definition: currentWord.definition, addedAt: new Date().toISOString() });
                saveWordBtn.textContent = "単語帳から削除";
                saveWordBtn.classList.replace("bg-[#1B1B1D]", "bg-red-500");
                highlightSavedWords(currentWord.word);
            } else {
                vocabularyItems.splice(wordIndex, 1);
                saveWordBtn.textContent = "単語帳に追加";
                saveWordBtn.classList.replace("bg-red-500", "bg-[#1B1B1D]");
                removeWordHighlight(currentWord.word);
            }
            
            localStorage.setItem('vocabulary', JSON.stringify(vocabularyItems));
            updateVocabularyCount();
            
            if (!vocabularyDrawer.classList.contains('hidden')) {
                renderVocabularyList();
            }
        }
        
        function isWordInVocabulary(word) {
            return vocabularyItems.some(item => item.word.toLowerCase() === word.toLowerCase());
        }
        
        function highlightSavedWords(word) {
            document.querySelectorAll('.clickable-word').forEach(el => {
                if (el.textContent.toLowerCase() === word.toLowerCase()) el.classList.add('saved-word');
            });
        }
        
        function removeWordHighlight(word) {
            document.querySelectorAll('.clickable-word').forEach(el => {
                if (el.textContent.toLowerCase() === word.toLowerCase()) el.classList.remove('saved-word');
            });
        }
        
        function updateVocabularyCount() {
            vocabularyCount.textContent = vocabularyItems.length;
        }
        
        function toggleVocabularyDrawer() {
            vocabularyDrawer.classList.contains('hidden') ? openVocabularyDrawer() : closeVocabularyDrawer();
        }
        
        function openVocabularyDrawer() {
            vocabularyDrawer.classList.remove('hidden');
            setTimeout(() => {
                vocabularyDrawer.classList.add('visible');
                renderVocabularyList();
            }, 10);
        }
        
        function closeVocabularyDrawer() {
            vocabularyDrawer.classList.remove('visible');
            setTimeout(() => vocabularyDrawer.classList.add('hidden'), 300);
        }
        
        function renderVocabularyList() {
            vocabularyList.innerHTML = "";
            if (vocabularyItems.length === 0) {
                vocabularyList.innerHTML = `
                    <div class="text-center p-6 text-gray-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" class="mx-auto mb-3 opacity-50"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"></path></svg>
                        <p class="font-bold">単語リストは空です</p>
                        <p class="text-sm mt-1">翻訳結果の単語をクリックして追加します</p>
                    </div>`;
                return;
            }
            
            const sortedItems = [...vocabularyItems].sort((a, b) => new Date(b.addedAt) - new Date(a.addedAt));
            
            sortedItems.forEach(item => {
                const vocabItem = document.createElement('div');
                vocabItem.className = "py-3 first:pt-0";
                
                const definitionText = item.definition?.definition || "意味の取得に失敗しました。";
                vocabItem.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <h4 class="font-bold text-lg">${item.word}</h4>
                        <div class="flex space-x-1">
                            <button class="play-vocab-btn p-1 rounded hover:bg-gray-100" data-word="${item.word}"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg></button>
                            <button class="delete-vocab-btn p-1 rounded hover:bg-gray-100 text-red-500" data-word="${item.word}"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                        </div>
                    </div>
                    ${item.definition?.pronunciation ? `<div class="text-sm text-gray-500 mb-1">${item.definition.pronunciation}</div>` : ''}
                    <p class="text-sm text-gray-700">${definitionText.length > 100 ? definitionText.substring(0, 97) + '...' : definitionText}</p>
                `;
                vocabularyList.appendChild(vocabItem);
            });

            vocabularyList.querySelectorAll('.play-vocab-btn').forEach(btn => btn.addEventListener('click', (e) => speakText(e.currentTarget.dataset.word, getLangCode(targetLangSelect.value))));
            vocabularyList.querySelectorAll('.delete-vocab-btn').forEach(btn => btn.addEventListener('click', (e) => removeVocabularyItem(e.currentTarget.dataset.word)));
        }
        
        function removeVocabularyItem(word) {
            const index = vocabularyItems.findIndex(item => item.word.toLowerCase() === word.toLowerCase());
            if (index !== -1) {
                vocabularyItems.splice(index, 1);
                localStorage.setItem('vocabulary', JSON.stringify(vocabularyItems));
                updateVocabularyCount();
                renderVocabularyList();
                removeWordHighlight(word);
                
                if (currentWord && currentWord.word.toLowerCase() === word.toLowerCase()) {
                    saveWordBtn.textContent = "単語帳に追加";
                    saveWordBtn.classList.replace("bg-red-500", "bg-[#1B1B1D]");
                }
            }
        }
        
        function clearVocabulary() {
            if (window.confirm("本当に単語帳をすべて削除しますか？この操作は元に戻せません。")) {
                vocabularyItems = [];
                localStorage.removeItem('vocabulary');
                updateVocabularyCount();
                renderVocabularyList();
                document.querySelectorAll('.saved-word').forEach(el => el.classList.remove('saved-word'));
                if (currentWord) {
                    saveWordBtn.textContent = "単語帳に追加";
                    saveWordBtn.classList.replace("bg-red-500", "bg-[#1B1B1D]");
                }
            }
        }

        // --- Bottom navigation functionality
        const navTabs = document.querySelectorAll('.nav-tab');
        const translationMode = document.getElementById('translation-mode');
        const learningMode = document.getElementById('learning-mode');
        
        navTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const mode = tab.dataset.mode;
                switchMode(mode);
            });
        });
        
        function switchMode(mode) {
            navTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mode === mode);
            });
            
            translationMode.classList.toggle('active', mode === 'translation');
            learningMode.classList.toggle('active', mode === 'learning');
            
            if (mode === 'learning') {
                setupLearningMode();
                closeVocabularyDrawer();
            }
        }
        
        // --- Learning Mode Functions ---
        function setupLearningMode() {
            const quizItems = vocabularyItems.filter(item => item.definition?.example?.source);
            const MIN_WORDS_FOR_QUIZ = 3;

            if (quizItems.length < MIN_WORDS_FOR_QUIZ) {
                learningModeContent.innerHTML = `
                    <div class="text-center py-12">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" class="mx-auto mb-4 text-gray-300">
                           <path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>
                        </svg>
                        <h3 class="text-xl font-bold text-gray-400 mb-2">単語が足りません</h3>
                        <p class="text-gray-500">クイズを始めるには、単語帳にあと${MIN_WORDS_FOR_QUIZ - quizItems.length}個の単語を追加してください。</p>
                    </div>
                `;
            } else {
                learningModeContent.innerHTML = `
                    <div class="text-center py-12">
                        <h3 class="text-2xl font-bold text-[#1B1B1D] mb-4">準備はいいですか？</h3>
                        <p class="text-gray-500 mb-6">単語帳の${quizItems.length}個の単語でクイズに挑戦しよう！</p>
                        <button id="start-quiz-btn" class="w-full max-w-xs mx-auto bg-[#1B1B1D] text-white font-extrabold text-lg py-3 px-4 rounded-lg hover:bg-opacity-90 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-[#1B1B1D]">
                            クイズを始める
                        </button>
                    </div>
                `;
                document.getElementById('start-quiz-btn').addEventListener('click', () => startQuiz(quizItems));
            }
        }

        function startQuiz(items) {
            quizState = {
                items: items.sort(() => 0.5 - Math.random()), // Shuffle items
                currentIndex: 0,
                score: 0
            };
            displayQuizQuestion();
        }

        function displayQuizQuestion() {
            if (quizState.currentIndex >= quizState.items.length) {
                displayQuizResults();
                return;
            }

            const item = quizState.items[quizState.currentIndex];
            const sentence = item.definition.example.source;
            const wordToGuess = item.word;
            const blankedSentence = sentence.replace(new RegExp(`\\b${wordToGuess}\\b`, 'gi'), '_______');

            learningModeContent.innerHTML = `
                <div class="space-y-4">
                    <div class="text-center text-sm text-gray-500 font-semibold">
                        Question ${quizState.currentIndex + 1} of ${quizState.items.length}
                    </div>
                    <div class="bg-gray-100 p-4 rounded-lg">
                        <p class="text-sm font-bold text-gray-500 mb-1">意味：</p>
                        <p class="font-semibold">${item.definition.definition}</p>
                    </div>
                    <div class="text-center text-xl font-bold my-4 p-4 bg-gray-50 rounded-lg">
                        ${blankedSentence}
                    </div>
                    <div id="quiz-feedback" class="h-6 text-center"></div>
                    <div class="flex gap-2">
                        <input type="text" id="quiz-input" class="w-full p-3 bg-white border-2 border-gray-200 rounded-lg font-bold text-[#1B1B1D] focus:ring-4 focus:ring-[#1B1B1D]/50 focus:border-[#1B1B1D] outline-none" placeholder="単語を入力...">
                        <button id="quiz-submit" class="bg-[#1B1B1D] text-white font-bold py-3 px-5 rounded-lg hover:bg-opacity-90">回答</button>
                    </div>
                </div>
            `;

            const input = document.getElementById('quiz-input');
            const submitBtn = document.getElementById('quiz-submit');
            
            submitBtn.addEventListener('click', handleQuizSubmit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleQuizSubmit();
                }
            });
            input.focus();
        }

        function handleQuizSubmit() {
            const input = document.getElementById('quiz-input');
            const userAnswer = input.value.trim();
            const correctAnswer = quizState.items[quizState.currentIndex].word;
            const feedbackEl = document.getElementById('quiz-feedback');
            const submitBtn = document.getElementById('quiz-submit');

            if (!userAnswer) return;
            
            submitBtn.disabled = true;
            input.disabled = true;

            if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                quizState.score++;
                feedbackEl.textContent = '正解！ 🎉';
                feedbackEl.className = 'h-6 text-center font-bold text-green-500';
                input.classList.add('border-green-500', 'ring-green-500/50');
                setTimeout(() => {
                    quizState.currentIndex++;
                    displayQuizQuestion();
                }, 1500);
            } else {
                feedbackEl.innerHTML = `不正解... 正解は: <span class="font-bold">${correctAnswer}</span>`;
                feedbackEl.className = 'h-6 text-center font-bold text-red-500';
                input.classList.add('border-red-500', 'ring-red-500/50');
                 setTimeout(() => {
                    quizState.currentIndex++;
                    displayQuizQuestion();
                }, 2500);
            }
        }
        
        function displayQuizResults() {
            const percentage = Math.round((quizState.score / quizState.items.length) * 100);
            learningModeContent.innerHTML = `
                <div class="text-center py-12">
                    <h3 class="text-2xl font-bold text-[#1B1B1D] mb-2">クイズ終了！</h3>
                    <p class="text-gray-500 mb-6">お疲れ様でした。</p>
                    <div class="text-5xl font-extrabold mb-2">${quizState.score} / ${quizState.items.length}</div>
                    <div class="text-2xl font-bold text-blue-600 mb-8">${percentage}% 正解</div>
                    <button id="restart-quiz-btn" class="w-full max-w-xs mx-auto bg-[#1B1B1D] text-white font-extrabold text-lg py-3 px-4 rounded-lg hover:bg-opacity-90">
                        もう一度挑戦
                    </button>
                </div>
            `;
            document.getElementById('restart-quiz-btn').addEventListener('click', setupLearningMode);
        }

        // --- Utility Functions ---
        function getLangCode(langName) {
            const langMap = {'English': 'en-US', 'Japanese': 'ja-JP', 'Spanish': 'es-ES', 'French': 'fr-FR', 'German': 'de-DE', 'Chinese': 'zh-CN', 'Korean': 'ko-KR'};
            return langMap[langName] || 'en-US';
        }

        function speakText(text, langCode) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            const voice = voices.find(v => v.lang === langCode);
            if (voice) utterance.voice = voice;
            window.speechSynthesis.speak(utterance);
        }

        function createSpeakButton(textToSpeak, iconColor) {
            const button = document.createElement('button');
            button.className = 'p-1.5 rounded-md hover:bg-black/10 transition-colors flex-shrink-0';
            button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" class="${iconColor}"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>`;
            button.title = "音声で聞く";
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                speakText(textToSpeak, getLangCode(targetLangSelect.value));
            });
            return button;
        }

        function createCopyButton(textToCopy, iconColor) {
            const button = document.createElement('button');
            button.className = 'p-1.5 rounded-md hover:bg-black/10 transition-colors flex-shrink-0';
            button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" class="${iconColor}"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
            button.title = "クリップボードにコピー";
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const originalIcon = button.innerHTML;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" class="${iconColor}"><path d="M20 6 9 17l-5-5"></path></svg>`;
                    setTimeout(() => { button.innerHTML = originalIcon; }, 2000);
                }).catch(err => console.error('Failed to copy text: ', err));
            });
            return button;
        }

        function showLoader(isLoading) {
            resultsContainer.classList.remove('hidden');
            loader.classList.toggle('hidden', !isLoading);
            translateBtn.disabled = isLoading;
            translateBtn.classList.toggle('opacity-50', isLoading);
            translateBtn.classList.toggle('cursor-not-allowed', isLoading);
        }

        function showError(msg) {
            resultsContainer.classList.remove('hidden');
            errorMessage.textContent = msg;
            errorMessage.classList.remove('hidden');
        }

        function clearResults() {
            errorMessage.classList.add('hidden');
            translationCards.innerHTML = '';
        }
    </script>
</body>
</html>
